import 'dart:convert';
import 'dart:io'; // Ajout de l'import pour WebSocket
import 'dart:async'; // Ajout de l'import pour StreamController
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:web_socket_channel/io.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger_service.dart';
import '../models/scenario_model.dart';
import '../models/session_model.dart';

class ApiService {
  static const String _tag = 'ApiService';

  final String baseUrl;
  final String? authToken; // Token d'authentification
  final String apiKey; // Cl√© API

  ApiService({String? baseUrl, this.authToken, required this.apiKey}) : baseUrl = baseUrl ?? AppConfig.apiBaseUrl {
    logger.i(_tag, 'Service API initialis√© avec URL: $baseUrl');
  }

  // Construire les en-t√™tes HTTP avec authentification si disponible
  Map<String, String> get headers {
    final Map<String, String> headers = {
      'Content-Type': 'application/json',
      'X-API-Key': apiKey, // Utiliser la cl√© API configurable
    };

    if (authToken != null) {
      headers['Authorization'] = 'Bearer $authToken';
      logger.v(_tag, 'En-t√™tes avec authentification et cl√© API');
    } else {
      logger.v(_tag, 'En-t√™tes sans authentification mais avec cl√© API');
    }

    // Ajouter des logs pour le d√©bogage
    logger.i(_tag, 'üîë Cl√© API utilis√©e dans les en-t√™tes: $apiKey');

    return headers;
  }

  // R√©cup√©rer la liste des sc√©narios
  Future<List<ScenarioModel>> getScenarios({
    String? type,
    String? difficulty,
    String language = 'fr',
  }) async {
    logger.i(_tag, 'R√©cup√©ration des sc√©narios');
    logger.performance(_tag, 'getScenarios', start: true);

    // Construire l'URL avec les param√®tres de requ√™te
    final queryParams = <String, String>{};
    if (type != null) queryParams['type'] = type;
    if (difficulty != null) queryParams['difficulty'] = difficulty;
    queryParams['language'] = language;

    // Utiliser l'URL avec le slash √† la fin
    final uri = Uri.parse('$baseUrl/api/scenarios/').replace(queryParameters: queryParams);
    logger.i(_tag, 'URL de requ√™te: $uri');
    logger.i(_tag, 'Adresse IP et port utilis√©s: ${uri.host}:${uri.port}');

    // Ajouter les en-t√™tes d'authentification
    final response = await http.get(uri, headers: headers)
        .timeout(const Duration(seconds: 10));

    if (response.statusCode == 200) {
      logger.i(_tag, 'Sc√©narios r√©cup√©r√©s avec succ√®s');

      // V√©rifier si la r√©ponse est vide
      if (response.body.isEmpty) {
        logger.e(_tag, 'R√©ponse vide du serveur');
        throw Exception('Le serveur a retourn√© une r√©ponse vide');
      }

      final List<dynamic> data = json.decode(response.body);
      logger.i(_tag, '${data.length} sc√©narios r√©cup√©r√©s');

      final scenarios = data.map((json) => ScenarioModel.fromJson(json)).toList();
      logger.performance(_tag, 'getScenarios', end: true);
      return scenarios;
    } else if (response.statusCode == 401) {
      logger.e(_tag, 'Erreur 401 (Non autoris√©) lors de la r√©cup√©ration des sc√©narios: ${response.body}');
      throw Exception('Acc√®s non autoris√©. Veuillez v√©rifier votre cl√© API.');
    } else if (response.statusCode == 403) {
      logger.e(_tag, 'Erreur 403 (Interdit) lors de la r√©cup√©ration des sc√©narios: ${response.body}');
      throw Exception('Acc√®s interdit. Vous n\'avez pas les permissions n√©cessaires.');
    } else if (response.statusCode == 429) {
      logger.e(_tag, 'Erreur 429 (Trop de requ√™tes) lors de la r√©cup√©ration des sc√©narios: ${response.body}');
      throw Exception('Trop de requ√™tes. Veuillez r√©essayer plus tard.');
    }
    else {
      // Pour le d√©bogage, afficher le corps de la r√©ponse
      logger.e(_tag, 'Erreur ${response.statusCode} lors de la r√©cup√©ration des sc√©narios: ${response.body}');
      logger.performance(_tag, 'getScenarios', end: true);
      throw Exception('Erreur ${response.statusCode} lors de la r√©cup√©ration des sc√©narios');
    }
  }

  // R√©cup√©rer un sc√©nario sp√©cifique
  Future<ScenarioModel?> getScenario(String scenarioId) async {
    try {
      logger.i(_tag, 'R√©cup√©ration du sc√©nario: $scenarioId');
      logger.performance(_tag, 'getScenario', start: true);

      // Utiliser l'URL avec le slash √† la fin
      final response = await http.get(
        Uri.parse('$baseUrl/api/scenarios/$scenarioId'),
        headers: headers
      );

      if (response.statusCode == 200) {
        logger.i(_tag, 'Sc√©nario r√©cup√©r√© avec succ√®s');
        final scenario = ScenarioModel.fromJson(json.decode(response.body));
        logger.performance(_tag, 'getScenario', end: true);
        return scenario;
      } else if (response.statusCode == 401) {
        logger.e(_tag, 'Erreur 401 (Non autoris√©) lors de la r√©cup√©ration du sc√©nario: ${response.body}');
        throw Exception('Acc√®s non autoris√©. Veuillez v√©rifier votre cl√© API.');
      } else if (response.statusCode == 403) {
        logger.e(_tag, 'Erreur 403 (Interdit) lors de la r√©cup√©ration du sc√©nario: ${response.body}');
        throw Exception('Acc√®s interdit. Vous n\'avez pas les permissions n√©cessaires.');
      } else if (response.statusCode == 429) {
        logger.e(_tag, 'Erreur 429 (Trop de requ√™tes) lors de la r√©cup√©ration du sc√©nario: ${response.body}');
        throw Exception('Trop de requ√™tes. Veuillez r√©essayer plus tard.');
      }
      else {
        logger.e(_tag, 'Erreur ${response.statusCode} lors de la r√©cup√©ration du sc√©nario: ${response.body}');
        logger.performance(_tag, 'getScenario', end: true);
        return null;
      }
    } catch (e) {
      logger.e(_tag, 'Exception lors de la r√©cup√©ration du sc√©nario: $e');
      logger.performance(_tag, 'getScenario', end: true);
      return null;
    }
  }

  // D√©marrer une session de coaching avec support pour l'ancien et le nouveau backend
  Future<SessionModel> startSession(
    String scenarioId,
    String userId, {
    String language = 'fr',
    String? goal,
    String? agentProfileId,
    bool isMultiAgent = false,
  }) async {
    // Pr√©parer le corps de la requ√™te pour le nouveau format
    final Map<String, dynamic> newRequestBody = {
      'user_id': userId,
      'language': language,
      'scenario_id': scenarioId,
    };
    
    // Ajouter les champs optionnels s'ils sont fournis
    if (goal != null) newRequestBody['goal'] = goal;
    if (agentProfileId != null) newRequestBody['agent_profile_id'] = agentProfileId;
    newRequestBody['is_multi_agent'] = isMultiAgent;
    
    final newFormatBody = json.encode(newRequestBody);
    
    // Pr√©parer le corps de la requ√™te pour l'ancien format
    final oldFormatBody = json.encode({
      'scenario_id': scenarioId,
      'user_id': userId,
      'language': language,
    });

    // Les en-t√™tes de base incluent d√©j√† X-API-Key
    final Map<String, String> requestHeaders = {...headers};

    // Essayer d'abord le nouvel endpoint
    final newUrl = '$baseUrl/api/sessions';
    logger.i(_tag, 'Tentative avec le nouvel endpoint: URL=$newUrl, Body=$newFormatBody');
    logger.performance(_tag, 'startSession', start: true);

    try {
      final response = await http.post(
        Uri.parse(newUrl),
        headers: requestHeaders,
        body: newFormatBody,
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        logger.i(_tag, 'Session LiveKit d√©marr√©e avec succ√®s (Code: ${response.statusCode})');
        
        // V√©rifier si la r√©ponse est vide
        if (response.body.isEmpty) {
          logger.e(_tag, 'R√©ponse vide du serveur');
          throw Exception('Le serveur a retourn√© une r√©ponse vide');
        }
        
        final sessionData = json.decode(response.body);
        logger.i(_tag, 'Donn√©es de session JSON d√©cod√©es (nouveau format)');
        
        // V√©rifier que les champs requis sont pr√©sents
        if (!sessionData.containsKey('session_id') ||
            !sessionData.containsKey('room_name') ||
            !sessionData.containsKey('token') ||
            !sessionData.containsKey('url')) {
          logger.e(_tag, 'Donn√©es de session incompl√®tes: ${sessionData.keys.join(', ')}');
          throw Exception('Donn√©es de session incompl√®tes');
        }
        
        final sessionId = sessionData['session_id'];
        final roomName = sessionData['room_name'];
        final livekitUrl = sessionData['url'];
        
        logger.i(_tag, 'Session ID: $sessionId, Room: $roomName, LiveKit URL: $livekitUrl');
        
        final session = SessionModel.fromJson(sessionData);
        logger.i(_tag, 'Session LiveKit cr√©√©e avec succ√®s: ${session.sessionId}');
        
        logger.performance(_tag, 'startSession', end: true);
        return session;
      } else if (response.statusCode == 404) {
        // Si le nouvel endpoint n'existe pas, essayer l'ancien endpoint
        logger.w(_tag, 'Nouvel endpoint non trouv√© (404), essai avec l\'ancien endpoint');
      } else if (response.statusCode == 401) {
        logger.e(_tag, 'Erreur 401 (Non autoris√©) lors du d√©marrage de la session: ${response.body}');
        throw Exception('Acc√®s non autoris√©. Veuillez v√©rifier votre cl√© API.');
      } else if (response.statusCode == 403) {
        logger.e(_tag, 'Erreur 403 (Interdit) lors du d√©marrage de la session: ${response.body}');
        throw Exception('Acc√®s interdit. Vous n\'avez pas les permissions n√©cessaires.');
      } else if (response.statusCode == 429) {
        logger.e(_tag, 'Erreur 429 (Trop de requ√™tes) lors du d√©marrage de la session: ${response.body}');
        throw Exception('Trop de requ√™tes. Veuillez r√©essayer plus tard.');
      }
      else {
        logger.e(_tag, 'Erreur HTTP (${response.statusCode}): ${response.body}');
        logger.performance(_tag, 'startSession', end: true);
        throw Exception('Erreur ${response.statusCode} lors du d√©marrage de la session LiveKit');
      }
    } catch (e) {
      if (e is! Exception || e.toString().contains('404')) {
        logger.w(_tag, 'Erreur avec le nouvel endpoint: $e, essai avec l\'ancien endpoint');
      } else {
        logger.e(_tag, 'Erreur lors de la connexion au nouvel endpoint: $e');
        logger.performance(_tag, 'startSession', end: true);
        rethrow;
      }
    }

    // Essayer l'ancien endpoint
    final oldUrl = '$baseUrl/api/session/start';
    logger.i(_tag, 'Utilisation de l\'ancien endpoint: URL=$oldUrl, Body=$oldFormatBody');

    try {
      final response = await http.post(
        Uri.parse(oldUrl),
        headers: headers,
        body: oldFormatBody,
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        logger.i(_tag, 'Session d√©marr√©e avec succ√®s via l\'ancien endpoint (Code: ${response.statusCode})');
        
        // V√©rifier si la r√©ponse est vide
        if (response.body.isEmpty) {
          logger.e(_tag, 'R√©ponse vide du serveur');
          throw Exception('Le serveur a retourn√© une r√©ponse vide');
        }
        
        final sessionData = json.decode(response.body);
        logger.i(_tag, 'Donn√©es de session JSON d√©cod√©es (ancien format)');
        
        // V√©rifier que les champs requis sont pr√©sents pour l'ancien format
        if (!sessionData.containsKey('session_id') ||
            !sessionData.containsKey('websocket_url') ||
            !sessionData.containsKey('initial_message')) {
          logger.e(_tag, 'Donn√©es de session incompl√®tes: ${sessionData.keys.join(', ')}');
          throw Exception('Donn√©es de session incompl√®tes');
        }
        
        // Cr√©er une session compatible avec le nouveau format √† partir de l'ancien format
        final sessionId = sessionData['session_id'];
        final websocketUrl = sessionData['websocket_url'];
        
        logger.i(_tag, 'Session ID: $sessionId, WebSocket URL: $websocketUrl');
        
        // Extraire l'URL de base pour LiveKit (utiliser l'URL configur√©e)
        final livekitUrl = AppConfig.livekitWsUrl;
        
        // Cr√©er un mod√®le de session compatible avec LiveKit
        final session = SessionModel(
          sessionId: sessionId,
          roomName: 'eloquence-$sessionId', // G√©n√©rer un nom de salle bas√© sur l'ID de session
          token: '', // Token vide, sera g√©n√©r√© par le service LiveKit
          livekitUrl: livekitUrl,
          initialMessage: Map<String, String>.from(sessionData['initial_message'] ?? {}),
        );
        
        logger.i(_tag, 'Session cr√©√©e avec succ√®s via l\'ancien endpoint: ${session.sessionId}');
        logger.i(_tag, 'URL LiveKit (configur√©e): ${session.livekitUrl}');
        
        logger.performance(_tag, 'startSession', end: true);
        return session;
      } else {
        logger.e(_tag, 'Erreur HTTP avec l\'ancien endpoint (${response.statusCode}): ${response.body}');
        logger.performance(_tag, 'startSession', end: true);
        throw Exception('Erreur ${response.statusCode} lors du d√©marrage de la session');
      }
    } catch (e) {
      logger.e(_tag, 'Erreur lors de la connexion √† l\'ancien endpoint: $e');
      logger.performance(_tag, 'startSession', end: true);
      throw Exception('Erreur lors du d√©marrage de la session: $e');
    }
  }

  // Cette m√©thode est d√©sormais obsol√®te car remplac√©e par LiveKit
  // Elle est conserv√©e pour la r√©trocompatibilit√© mais l√®ve une exception
  @Deprecated('Utilisez LiveKit au lieu de WebSocket')
  Future<WebSocketChannel> connectWebSocket(String sessionId) async {
    logger.e(_tag, 'La m√©thode connectWebSocket est obsol√®te. Utilisez LiveKit √† la place.');
    throw Exception('La m√©thode connectWebSocket est obsol√®te. Utilisez LiveKit √† la place.');
  }

  // Terminer une session de coaching avec support pour l'ancien et le nouveau backend
  Future<bool> endSession(String sessionId) async {
    logger.i(_tag, 'Fin de la session: $sessionId');
    logger.performance(_tag, 'endSession', start: true);

    // Les en-t√™tes de base incluent d√©j√† X-API-Key
    final Map<String, String> requestHeaders = {...headers};

    // Essayer d'abord le nouvel endpoint
    final newUrl = '$baseUrl/api/sessions/$sessionId';
    logger.i(_tag, 'Tentative avec le nouvel endpoint: URL=$newUrl');

    try {
      final response = await http.delete(
        Uri.parse(newUrl),
        headers: requestHeaders,
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        logger.i(_tag, 'Session termin√©e avec succ√®s via le nouvel endpoint');
        logger.performance(_tag, 'endSession', end: true);
        return true;
      } else if (response.statusCode == 404) {
        // Si le nouvel endpoint n'existe pas, essayer l'ancien endpoint
        logger.w(_tag, 'Nouvel endpoint non trouv√© (404), essai avec l\'ancien endpoint');
      } else if (response.statusCode == 401) {
        logger.e(_tag, 'Erreur 401 (Non autoris√©) lors de la fin de la session: ${response.body}');
        throw Exception('Acc√®s non autoris√©. Veuillez v√©rifier votre cl√© API.');
      } else if (response.statusCode == 403) {
        logger.e(_tag, 'Erreur 403 (Interdit) lors de la fin de la session: ${response.body}');
        throw Exception('Acc√®s interdit. Vous n\'avez pas les permissions n√©cessaires.');
      } else if (response.statusCode == 429) {
        logger.e(_tag, 'Erreur 429 (Trop de requ√™tes) lors de la fin de la session: ${response.body}');
        throw Exception('Trop de requ√™tes. Veuillez r√©essayer plus tard.');
      }
      else {
        logger.e(_tag, 'Erreur HTTP avec le nouvel endpoint (${response.statusCode}): ${response.body}');
      }
    } catch (e) {
      logger.w(_tag, 'Erreur avec le nouvel endpoint: $e, essai avec l\'ancien endpoint');
    }

    // Essayer l'ancien endpoint
    final oldUrl = '$baseUrl/api/session/$sessionId/end';
    logger.i(_tag, 'Utilisation de l\'ancien endpoint: URL=$oldUrl');

    try {
      final response = await http.post(
        Uri.parse(oldUrl),
        headers: headers,
      ).timeout(const Duration(seconds: 10));

      final success = response.statusCode == 200;
      if (success) {
        logger.i(_tag, 'Session termin√©e avec succ√®s via l\'ancien endpoint');
      } else {
        logger.e(_tag, 'Erreur lors de la fin de la session via l\'ancien endpoint: ${response.statusCode} - ${response.body}');
      }

      logger.performance(_tag, 'endSession', end: true);
      return success;
    } catch (e) {
      logger.e(_tag, 'Erreur lors de la connexion √† l\'ancien endpoint: $e');
      logger.performance(_tag, 'endSession', end: true);
      return false;
    }
  }
}
