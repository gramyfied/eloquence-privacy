import 'dart:typed_data';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/utils/logger_service.dart';
import '../../data/services/audio_adapter_v7_buffered.dart';
import '../../data/models/session_model.dart';
import 'livekit_provider.dart';
import 'audio_provider.dart';

/// Provider pour l'adaptateur audio LiveKit avec solution V6 Simple
final liveKitAudioAdapterProvider = Provider<AudioAdapterV7Buffered>((ref) {
  final liveKitService = ref.watch(liveKitServiceProvider);
  final adapter = AudioAdapterV7Buffered(liveKitService);
  
  // Nettoyer les ressources lorsque le provider est d√©truit
  ref.onDispose(() {
    adapter.dispose();
  });
  
  return adapter;
});

/// Provider pour l'√©tat de la conversation avec LiveKit
final liveKitConversationProvider = StateNotifierProvider<LiveKitConversationNotifier, ConversationState>((ref) {
  final adapter = ref.watch(liveKitAudioAdapterProvider);
  return LiveKitConversationNotifier(adapter);
});

/// Notifier pour g√©rer l'√©tat de la conversation avec LiveKit
class LiveKitConversationNotifier extends StateNotifier<ConversationState> {
  static const String _tag = 'LiveKitConversationNotifier';
  
  final AudioAdapterV7Buffered _adapter;
  bool _adapterInitialized = false;
  
  LiveKitConversationNotifier(this._adapter) : super(const ConversationState()) {
    // Initialiser l'adaptateur V6 de mani√®re asynchrone
    _initializeAdapter();
    
    // Configurer les callbacks de l'adaptateur
    _adapter.onTextReceived = _onTextReceived;
    _adapter.onError = _onError;
    // Note: V6 g√®re onAudioUrlReceived et onFeedbackReceived via handleJsonData
  }
  
  /// Initialise l'adaptateur V6
  Future<void> _initializeAdapter() async {
    try {
      final success = await _adapter.initialize();
      if (success) {
        _adapterInitialized = true;
        logger.i(_tag, '‚úÖ Adaptateur V6 initialis√© avec succ√®s');
      } else {
        logger.e(_tag, '‚ùå √âchec de l\'initialisation de l\'adaptateur V6');
        state = state.copyWith(
          error: 'Impossible d\'initialiser l\'adaptateur audio',
        );
      }
    } catch (e) {
      logger.e(_tag, '‚ùå Erreur lors de l\'initialisation de l\'adaptateur V6: $e');
      state = state.copyWith(
        error: 'Erreur d\'initialisation: $e',
      );
    }
  }
  
  /// Connecte √† LiveKit avec les informations de session
  Future<void> connectWithSession(SessionModel session) async {
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] ===== D√âBUT CONNEXION LIVEKIT =====');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] Session ID: ${session.sessionId}');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] Room Name: ${session.roomName}');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] LiveKit URL: ${session.livekitUrl}');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] Token pr√©sent: ${session.token.isNotEmpty}');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] Token longueur: ${session.token.length}');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] √âtat initial - isConnecting: ${state.isConnecting}, isConnected: ${state.isConnected}');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] AudioAdapter isConnected: ${_adapter.isConnected}');
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] AudioAdapter isInitialized: ${_adapter.isInitialized}');
    
    // V√©rifier si nous sommes d√©j√† en train de nous connecter
    if (state.isConnecting) {
      logger.w(_tag, '‚ö†Ô∏è [DIAGNOSTIC_COMPLET] Connexion d√©j√† en cours, attente avant nouvelle tentative');
      
      // Attendre un court d√©lai avant de r√©essayer
      await Future.delayed(const Duration(milliseconds: 500));
      
      // V√©rifier √† nouveau si nous sommes toujours en train de nous connecter
      if (state.isConnecting) {
        logger.w(_tag, '‚ö†Ô∏è [DIAGNOSTIC_COMPLET] Connexion toujours en cours apr√®s d√©lai, annulation de la nouvelle tentative');
        return;
      }
    }
    
    // Si nous sommes d√©j√† connect√©s, d√©connecter d'abord
    if (state.isConnected) {
      logger.i(_tag, 'üîÑ [DIAGNOSTIC_COMPLET] D√©j√† connect√©, d√©connexion avant nouvelle connexion');
      await _disconnectSafely();
    }
    
    // Mettre √† jour l'√©tat pour indiquer que la connexion est en cours
    logger.i(_tag, 'üîÑ [DIAGNOSTIC_COMPLET] Mise √† jour √©tat: isConnecting=true, isConnected=false');
    state = state.copyWith(
      isConnecting: true,
      isConnected: false,
      connectionError: null,
    );
    
    try {
      // V√©rifier que l'adaptateur est initialis√©
      if (!_adapterInitialized) {
        logger.i(_tag, 'üîß [DIAGNOSTIC_COMPLET] Attente de l\'initialisation de l\'adaptateur V6...');
        await _initializeAdapter();
        
        if (!_adapterInitialized) {
          throw Exception('Impossible d\'initialiser l\'adaptateur audio V6');
        }
      }
      
      // CORRECTION : D√©clencher la connexion r√©elle √† LiveKit via AudioAdapterV6
      logger.i(_tag, 'üîß [DIAGNOSTIC_COMPLET] D√©clenchement de la connexion LiveKit r√©elle...');
      logger.i(_tag, 'üîß [DIAGNOSTIC_COMPLET] Appel de _adapter.connectToLiveKit()...');
      
      // Appeler la m√©thode connectToLiveKit de l'adaptateur V6
      final success = await _adapter.connectToLiveKit(session);
      
      logger.i(_tag, 'üîß [DIAGNOSTIC_COMPLET] R√©sultat connectToLiveKit: $success');
      logger.i(_tag, 'üîß [DIAGNOSTIC_COMPLET] AudioAdapter isConnected apr√®s connexion: ${_adapter.isConnected}');
      
      if (success) {
        // Mettre √† jour l'√©tat pour indiquer que la connexion est √©tablie
        state = state.copyWith(
          isConnecting: false,
          isConnected: true,
          connectionError: null,
        );
        
        logger.i(_tag, '‚úÖ [DIAGNOSTIC_COMPLET] Connexion LiveKit √©tablie avec succ√®s via AudioAdapterV6');
        logger.i(_tag, '‚úÖ [DIAGNOSTIC_COMPLET] √âtat final - isConnecting: ${state.isConnecting}, isConnected: ${state.isConnected}');
      } else {
        // Mettre √† jour l'√©tat pour indiquer que la connexion a √©chou√©
        state = state.copyWith(
          isConnecting: false,
          isConnected: false,
          connectionError: '√âchec de la connexion LiveKit',
        );
        
        logger.e(_tag, '‚ùå [DIAGNOSTIC_COMPLET] √âchec de la connexion LiveKit');
        logger.e(_tag, '‚ùå [DIAGNOSTIC_COMPLET] √âtat final - isConnecting: ${state.isConnecting}, isConnected: ${state.isConnected}');
      }
    } catch (e, stackTrace) {
      // Mettre √† jour l'√©tat pour indiquer que la connexion a √©chou√©
      state = state.copyWith(
        isConnecting: false,
        isConnected: false,
        connectionError: 'Erreur de connexion LiveKit: $e',
      );
      
      logger.e(_tag, '‚ùå [DIAGNOSTIC_COMPLET] Exception lors de la connexion LiveKit: $e');
      logger.e(_tag, '‚ùå [DIAGNOSTIC_COMPLET] StackTrace: $stackTrace');
      logger.e(_tag, '‚ùå [DIAGNOSTIC_COMPLET] √âtat final - isConnecting: ${state.isConnecting}, isConnected: ${state.isConnected}');
    }
    
    logger.i(_tag, 'üöÄ [DIAGNOSTIC_COMPLET] ===== FIN CONNEXION LIVEKIT =====');
  }
  
  /// D√©connecte en toute s√©curit√©
  Future<void> _disconnectSafely() async {
    logger.i(_tag, 'D√©connexion s√©curis√©e');
    
    try {
      // Mettre √† jour l'√©tat pour indiquer que nous sommes en train de nous d√©connecter
      state = state.copyWith(
        isConnecting: false,
        isConnected: false,
      );
      
      // D√©connecter l'adaptateur
      await _adapter.dispose();
      
      // Attendre un court d√©lai pour s'assurer que la d√©connexion est compl√®te
      await Future.delayed(const Duration(milliseconds: 300));
      
      logger.i(_tag, 'D√©connexion r√©ussie');
    } catch (e) {
      logger.e(_tag, 'Erreur lors de la d√©connexion', e);
    }
  }
  
  /// Connecte au WebSocket avec reconnexion automatique (m√©thode de compatibilit√©)
  @Deprecated('Utilisez connectWithSession √† la place')
  Future<void> connectWebSocket(String wsUrl) async {
    logger.i(_tag, 'Connexion au WebSocket via LiveKit: $wsUrl');
    logger.w(_tag, 'Cette m√©thode est obsol√®te. Utilisez connectWithSession √† la place.');
    
    // L'adaptateur continu ne supporte pas connectWebSocket
    // On simule juste la connexion r√©ussie
    state = state.copyWith(
      isConnecting: false,
      isConnected: true,
      connectionError: null,
    );
    
    logger.i(_tag, 'Connexion WebSocket simul√©e avec succ√®s via adaptateur continu');
  }
  
  /// Force une reconnexion manuelle
  Future<void> reconnect() async {
    logger.i(_tag, 'Reconnexion manuelle demand√©e');
    
    // L'adaptateur continu g√®re automatiquement la reconnexion
    // On simule juste une reconnexion r√©ussie
    state = state.copyWith(
      isConnecting: false,
      isConnected: true,
      connectionError: null,
    );
    
    logger.i(_tag, 'Reconnexion simul√©e avec succ√®s (adaptateur continu)');
  }
  
  /// D√©marre l'enregistrement avec AudioAdapterFix
  Future<void> startRecording() async {
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER] ===== D√âBUT D√âMARRAGE ENREGISTREMENT PROVIDER =====');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER] √âtat initial provider:');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER]   - isRecording: ${state.isRecording}');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER]   - isConnected: ${state.isConnected}');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER]   - isProcessing: ${state.isProcessing}');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER]   - error: ${state.error}');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER] √âtat AudioAdapter:');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER]   - _adapter.isConnected: ${_adapter.isConnected}');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER]   - _adapter.isRecording: ${_adapter.isRecording}');
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER]   - _adapter.isInitialized: ${_adapter.isInitialized}');
    
    logger.performance(_tag, 'userInteraction', start: true);
    
    // V√©rifier que l'adaptateur est initialis√©
    if (!_adapterInitialized) {
      logger.e(_tag, '‚ùå [DIAGNOSTIC_PROVIDER] Adaptateur V6 non initialis√©');
      state = state.copyWith(
        isRecording: false,
        error: 'Adaptateur audio non initialis√©',
      );
      return;
    }
    
    // Utiliser la m√©thode startRecording d'AudioAdapterV6
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER] Appel de _adapter.startRecording()...');
    final success = await _adapter.startRecording();
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER] R√©sultat _adapter.startRecording(): $success');
    
    if (success) {
      state = state.copyWith(isRecording: true, isProcessing: false);
      logger.i(_tag, '‚úÖ [DIAGNOSTIC_PROVIDER] Enregistrement d√©marr√© avec succ√®s via AudioAdapterV6');
      logger.i(_tag, '‚úÖ [DIAGNOSTIC_PROVIDER] √âtat final provider - isRecording: ${state.isRecording}');
    } else {
      logger.e(_tag, '‚ùå [DIAGNOSTIC_PROVIDER] √âchec du d√©marrage de l\'enregistrement');
      state = state.copyWith(
        isRecording: false,
        error: 'Impossible de d√©marrer l\'enregistrement',
      );
      logger.e(_tag, '‚ùå [DIAGNOSTIC_PROVIDER] √âtat final provider - isRecording: ${state.isRecording}, error: ${state.error}');
    }
    
    logger.i(_tag, 'üéôÔ∏è [DIAGNOSTIC_PROVIDER] ===== FIN D√âMARRAGE ENREGISTREMENT PROVIDER =====');
  }
  
  /// Arr√™te l'enregistrement avec AudioAdapterV6
  Future<void> stopRecording() async {
    logger.i(_tag, 'Arr√™t de l\'enregistrement avec AudioAdapterV6');
    
    // Utiliser la m√©thode stopRecording d'AudioAdapterV6
    final success = await _adapter.stopRecording();
    
    if (success) {
      state = state.copyWith(isRecording: false, isProcessing: true);
      logger.i(_tag, '[DEBUG] Enregistrement arr√™t√© avec succ√®s via AudioAdapterV6');
    } else {
      logger.e(_tag, '√âchec de l\'arr√™t de l\'enregistrement');
      state = state.copyWith(
        isRecording: false,
        error: 'Impossible d\'arr√™ter l\'enregistrement',
      );
    }
    
    logger.performance(_tag, 'userInteraction', end: true);
  }
  
  /// Envoie un chunk audio au serveur (mode continu - automatique)
  void sendAudioChunk(Uint8List audioData) {
    if (state.isConnected && audioData.isNotEmpty) {
      logger.v(_tag, 'Chunk audio de ${audioData.length} octets (trait√© automatiquement en mode continu)');
      // L'adaptateur continu traite automatiquement l'audio
      // Pas besoin d'envoyer manuellement les chunks
    }
  }
  
  /// G√®re la r√©ception de texte
  void _onTextReceived(String text) {
    logger.i(_tag, 'Texte re√ßu: $text');
    
    state = state.copyWith(
      lastMessage: text,
      isProcessing: false,
      messages: [...state.messages, Message(text: text, isUser: false)],
    );
    
    // Mesurer le temps de r√©ponse total
    logger.networkLatency(_tag, 'Temps de r√©ponse total', 
      DateTime.now().difference(state.lastUserInteractionTime ?? DateTime.now()).inMilliseconds);
  }
  
  // Note: AudioAdapterV6 g√®re les URL audio et le feedback via handleJsonData
  // Ces m√©thodes ne sont plus n√©cessaires car elles sont int√©gr√©es dans V6
  
  /// G√®re les erreurs
  void _onError(String error) {
    logger.e(_tag, 'Erreur: $error');
    
    state = state.copyWith(
      error: error,
      isRecording: false,
      isProcessing: false,
    );
  }
  
  
  /// Efface l'erreur
  void clearError() {
    logger.i(_tag, 'Effacement de l\'erreur');
    
    state = state.copyWith(error: null);
  }
  
  /// Ajoute un message utilisateur
  void addUserMessage(String text) {
    logger.i(_tag, 'Ajout d\'un message utilisateur: $text');
    
    state = state.copyWith(
      messages: [...state.messages, Message(text: text, isUser: true)],
      lastUserInteractionTime: DateTime.now(),
    );
  }
  
  @override
  void dispose() {
    // L'adaptateur V6 g√®re son propre lecteur audio
    super.dispose();
  }
}